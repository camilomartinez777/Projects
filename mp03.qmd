---
title: "# Mini-Project #03: Do Proportional Electoral College Allocations Yield a More Representative Presidency?"
author: "Juan Camilo Martinez Benavides"
output:
  html_document:
    code_folding: hide
---


------------------------------------------------------------------------

## Introduction

In the United States, the President isn’t chosen directly by popular vote. Instead, the winner is determined through the [Electoral College](https://en.wikipedia.org/wiki/United_States_Electoral_College), a system in which each state’s influence is tied to its congressional representation. With the 2024 Presidential election drawing near, it’s timely to ask: **Would a different allocation method for electoral votes result in election outcomes that better represent the national popular vote?**

This project dives into this question, analyzing historical congressional and presidential election data from [MIT’s Election Data Science Lab](https://electionlab.mit.edu/) and [UCLA Congressional Boundary Files](https://cdmaps.polisci.ucla.edu/). By exploring electoral vote distributions under different allocation rules, we aim to see how alternate methods might change election results.

------------------------------------------------------------------------

## Background

### How the Electoral College Works

The U.S. Constitution sets the foundation of the Electoral College, granting each state a number of electors equal to its congressional delegation: the number of House representatives plus two senators. Most states follow a **winner-take-all** rule, where the state’s popular vote winner claims all electoral votes. However, states like Nebraska and Maine use a **district-wide allocation** method, awarding votes by individual district results, with two additional votes for the statewide popular winner.

In this analysis, we’ll test four allocation strategies to see their potential impact: 1. **State-Wide Winner-Take-All** 2. **District-Wide Winner-Take-All with At-Large Votes** 3. **State-Wide Proportional** 4. **National Proportional**

------------------------------------------------------------------------

## Data Collection

### Setting Up the Libraries and Data

We start by loading the necessary `R` packages for data manipulation and visualization.

```{r}
#| echo: true
#| message: false
#| warning: false
library(readr)
library(dplyr)
library(tidyr)
library(ggplot2)
library(sf)
library(stringr)
library(statebins)
library(scales)
library(usmap)
library(gt)
library(DT)
library(gganimate)
library(maps)
library(gifski)

```

## Data Sources and Import

The project uses two primary datasets:

U.S. House Election Data (1976–2022): Details vote counts from congressional races across the 50 states. U.S. Presidential Election Data (1976–2020): Provides state-level vote counts for presidential elections.

```{r}
#| echo: true
#| message: false
#| warning: false
DATA_HOUSE <- read_csv("1976-2022-house.csv") |> filter(!is.na(party))
DATA_PRESIDENT <- read_csv("1976-2020-president.csv") |>  filter(!is.na(candidate) & !is.na(party_detailed))
```

Additionally, we download congressional boundary files for spatial analysis, covering elections from 1976 to 2012 from UCLA and from 2013 to 2023 from the U.S. Census Bureau.

First, we download the UCLA congressional boundary files.
```{r}
#| echo: true
#| message: false
#| warning: false
congress_shapefiles_ucla <- function(start = 95, end = 112) {
  BASE_URL <- "https://cdmaps.polisci.ucla.edu/shp/districts"
  
  # Create directory if it doesn't exist
  target_dir <- "data/congress_shapefiles"
  if (!dir.exists(target_dir)) {
    dir.create(target_dir, recursive = TRUE)
  }
  
  for (congress in start:end) {
    congress_str <- sprintf("%03d", congress)
    file_url <- paste0(BASE_URL, congress_str, ".zip")
    dest_file <- file.path(target_dir, paste0("congress_", congress_str, "_shapefile.zip"))
    
    # Avoid re-downloading
    if (!file.exists(dest_file)) {
      tryCatch({
        download.file(file_url, destfile = dest_file, mode = "wb")
        # Check if the file is downloaded successfully
        if (file.size(dest_file) > 0) {
          message("Successfully downloaded shapefile for Congress ", congress_str)
        } else {
          file.remove(dest_file)
          message("Download failed for Congress ", congress_str, ". File was empty and deleted.")
        }
      }, error = function(e) {
        message("Error downloading for Congress ", congress_str, ": ", e)
      })
    } else {
      message("File for Congress ", congress_str, " already exists. Skipping download.")
    }
  }
}

#function
congress_shapefiles_ucla(93,112)
```

Now, we download the U.S. Census Bureau congressional boundary files.

```{r}
#| echo: true
#| message: false
#| warning: false
# Define function to download, unzip, and read a shapefile
download_and_read_shapefile <- function(year, congress_num) {
  # Set base URL and target directory
  base_url <- sprintf("https://www2.census.gov/geo/tiger/TIGER%d/CD/", year)
  target_dir <- "data/congress_shapefiles"
  
  # Create directory if it doesn't exist
  if (!dir.exists(target_dir)) dir.create(target_dir, recursive = TRUE)
  
  # Construct filename and paths
  file_name <- sprintf("tl_%d_us_cd%d", year, congress_num)
  zip_file <- file.path(target_dir, paste0(file_name, ".zip"))
  unzip_dir <- file.path(target_dir, file_name)
  shapefile_path <- file.path(unzip_dir, paste0(file_name, ".shp"))
  
  # Download the file if it doesn't exist
  if (!file.exists(zip_file)) {
    file_url <- paste0(base_url, file_name, ".zip")
    tryCatch({
      download.file(file_url, destfile = zip_file, mode = "wb")
      if (file.size(zip_file) > 0) {
        message("Downloaded: ", file_name, " for year ", year)
      } else {
        file.remove(zip_file)
        message("Download failed for ", file_name, ". Empty file removed.")
      }
    }, error = function(e) {
      message("Error downloading ", file_name, ": ", e$message)
    })
  }
  
  # Unzip and read the shapefile if it hasn’t been unzipped already
  if (file.exists(zip_file) && !file.exists(shapefile_path)) {
    unzip(zipfile = zip_file, exdir = unzip_dir)
  }
  
  # Load the shapefile if it exists
  if (file.exists(shapefile_path)) {
    return(read_sf(shapefile_path))
  } else {
    message("Shapefile not found for ", file_name, " in year ", year)
    return(NULL)
  }
}
# Iterate over years and download shapefiles based on Congress sessions
base_year <- 2022
for (i in 0:10) {
  year <- base_year - i
  
  # Determine Congress number based on the year
  congress <- if (year >= 2018) 116
              else if (year >= 2016) 115
              else if (year >= 2014) 114
              else if (year == 2013) 113
              else if (year == 2012) 112
              else NA
  
  if (!is.na(congress)) {
    district_name <- sprintf("tl_%d_us_cd%d", year, congress)
    
    # Download and read shapefile
    district_data <- download_and_read_shapefile(year, congress)
    
    # Assign the data to a unique variable in the global environment
    if (!is.null(district_data)) {
      assign(district_name, district_data, envir = .GlobalEnv)
    }
  } else {
    message("Congress data not available for year ", year)
  }
}
```

###Initial Exploration of Vote Count Data

Analyze Seat Gains and Losses in the U.S. House (1976-2022) This code calculates which states gained or lost the most seats in the House of Representatives between 1976 and 2022.

```{r}

# Filter House data for relevant years and calculate seat counts
house_seats_over_time <- DATA_HOUSE |>
  filter(year %in% c(1976, 2022)) |>
  distinct(year, state, district) |>
  group_by(year, state) |>
  summarise(total_seats = n(), .groups = "drop")

# Calculate seat changes from 1976 to 2022
seat_changes <- house_seats_over_time |>
  pivot_wider(names_from = year, values_from = total_seats, names_prefix = "year_") |>
  mutate(seat_change = year_2022 - year_1976) |>
  arrange(desc(seat_change))

# Identify top 5 states with highest seat gains and losses
top_gained_states <- seat_changes |> slice_max(seat_change, n = 5)
top_lost_states <- seat_changes |> slice_min(seat_change, n = 5)

# Plot top gained seats
plot_seat_gains <- ggplot(top_gained_states, aes(x = reorder(state, seat_change), y = seat_change, fill = seat_change)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  labs(title = "Top 5 States with Seat Gains (1976-2022)",
       x = "State",
       y = "Number of Seats Gained") +
  scale_fill_gradient(low = "lightblue", high = "darkblue") +
  theme_minimal()

# Plot top lost seats
plot_seat_losses <- ggplot(top_lost_states, aes(x = reorder(state, seat_change), y = seat_change, fill = -seat_change)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  labs(title = "Top 5 States with Seat Losses (1976-2022)",
       x = "State",
       y = "Number of Seats Lost") +
  scale_fill_gradient(low = "lightcoral", high = "darkred") +
  theme_minimal()

# Display both plots
list(plot_seat_gains, plot_seat_losses)


```

As we can see in this graph, the states that gained the most seats are Texas, Florida, California, Arizona, and Georgia. On the other hand, the states that lost the most seats are New York, Ohio, Pennsylvania, Illinois, Ohio, and Michigan. The following table explains the population growth between 1976 to 2022 shifts are the main reason for these changes.

| Location         | Growth Percentage |
|------------------|-------------------|
| **Arizona**      | 192.0%            |
| **Florida**      | 161.9%            |
| **Texas**        | 145.9%            |
| **Georgia**      | 125.0%            |
| **California**   | 77.3%             |
| **USA**          | 52.8%             |
| **Illinois**     | 12.5%             |
| **Pennsylvania** | 10.2%             |
| **New York**     | 10.1%             |
| **Ohio**         | 9.3%              |
| **Michigan**     | 8.1%              |

We see clearly that the Usa is in the middle of the list, and the states that lost the most seats are in the bottom of the list.

```{r}
#| echo: true
#| message: false
#| warning: false
# Filter for New York State and relevant House races
ny_house_data <- DATA_HOUSE |>
  filter(state == "NEW YORK", office == "US HOUSE")

# Calculate total votes (with fusion) and major party votes (without fusion)
fusion_analysis <- ny_house_data |>
  mutate(is_major_party = party %in% c("DEMOCRAT", "REPUBLICAN")) |>
  group_by(year, district, candidate) |>
  summarise(
    total_votes_all_lines = sum(candidatevotes, na.rm = TRUE),
    major_party_votes = sum(candidatevotes[is_major_party], na.rm = TRUE),
    .groups = "drop"
  )

# Determine winners by both fusion and non-fusion scenarios
winners_fusion <- fusion_analysis |>
  group_by(year, district) |>
  filter(total_votes_all_lines == max(total_votes_all_lines)) |>
  select(year, district, candidate, total_votes_all_lines) |>
  rename(fusion_winner = candidate, fusion_votes = total_votes_all_lines)|>
  ungroup()

winners_nonfusion <- fusion_analysis |>
  group_by(year, district) |>
  filter(major_party_votes == max(major_party_votes)) |>
  select(year, district, candidate, major_party_votes) |>
  rename(nonfusion_winner = candidate, nonfusion_votes = major_party_votes) |>
  ungroup()

# Find elections where fusion changed the winner
election_outcomes <- winners_fusion |>
  inner_join(winners_nonfusion, by = c("year", "district")) |>
  filter(fusion_winner != nonfusion_winner) |>
  arrange(desc(year))
  

datatable(
  election_outcomes,
  options = list(
    pageLength = 10,         # Rows per page
    autoWidth = TRUE,        # Adjust columns automatically
    dom = 'tip',             # Only show table, info, and pagination
    lengthMenu = c(5, 10, 15, 20)  # Options for rows per page
  ),
  rownames = FALSE           # Hide row names
)


```

As we can see, fusion voting can be a deciding factor in elections. The table demonstrates that fusion voting increases the likelihood of being elected by enabling candidates to gather votes from multiple party lines. This consolidates support in a way that would not be possible without fusion, giving fusion candidates a strategic advantage.

###Analyzing Presidential vs. Congressional Vote Patterns Across Parties

This analysis explores whether presidential candidates tend to run ahead of or behind their congressional counterparts in the same state. Specifically, we’re investigating if Democratic and Republican presidential candidates receive more votes in a given state than all congressional candidates from their party in that same state.

The following code will compare these vote counts, identifying instances where presidential candidates either outperformed ("ahead") or underperformed ("behind") their co-partisans. This will also help us understand if this trend varies over time, across states, or between parties, providing insights into the relative popularity of presidential candidates within each party.

```{r}
#| echo: true
#| message: false
#| warning: false
# Aggregate Democratic and Republican presidential votes by state and year
presidential_votes <- DATA_PRESIDENT |>
  filter(office == "US PRESIDENT", party_simplified %in% c("DEMOCRAT", "REPUBLICAN")) |>
  group_by(year, state, party_simplified) |>
  summarise(total_pres_votes = sum(candidatevotes, na.rm = TRUE), .groups = "drop")

# Aggregate Democratic and Republican congressional votes by state and year
congressional_votes <- DATA_HOUSE |>
  filter(office == "US HOUSE", party %in% c("DEMOCRAT", "REPUBLICAN")) |>
  group_by(year, state, party) |>
  summarise(total_congress_votes = sum(candidatevotes, na.rm = TRUE), .groups = "drop") |>
  rename(party_simplified = party)

# Merge the presidential and congressional vote data
vote_comparison <- presidential_votes |>
  inner_join(congressional_votes, by = c("year", "state", "party_simplified")) |>
  mutate(
    vote_difference = total_pres_votes - total_congress_votes,
    ran_ahead = ifelse(vote_difference > 0, "Ahead", "Behind")
  )

# Additional Visualization: Calculate the average vote difference per year across all states
avg_vote_diff <- vote_comparison |>
  group_by(year, party_simplified) |>
  summarise(avg_vote_difference = mean(vote_difference, na.rm = TRUE), .groups = "drop")

# Line chart for average vote difference over time
ggplot(avg_vote_diff, aes(x = year, y = avg_vote_difference, color = party_simplified)) +
  geom_line(size = 1.2) +
  geom_point(size = 3) +
  labs(
    title = "Average Vote Difference Between Presidential and Congressional Candidates",
    subtitle = "Across All States, by Party (1976 - 2020)",
    x = "Year",
    y = "Average Vote Difference (Presidential - Congressional)",
    color = "Party"
  ) +
  scale_color_manual(values = c("DEMOCRAT" = "blue", "REPUBLICAN" = "red")) +

  theme_minimal() +
  theme(legend.position = "top")
```

As we can see in the image, the average vote difference between presidential and congressional candidates has fluctuated over the years. On this, we can see a major fluctuation in the Republican party, what indicate that the presidential candidate has a major influence on votes than the congressional candidates. For Democrats, the difference is not that big, but still, the presidential candidate has a major influence on votes than the congressional candidates.

```{r}
#| echo: true
#| message: false
#| warning: false
# Summary of total instances where presidential candidates ran ahead or behind, grouped by party
party_summary_stats <- vote_comparison |>
  group_by(party_simplified) |>
  summarise(
    total_ahead = sum(ran_ahead == "Ahead"),
    total_behind = sum(ran_ahead == "Behind"),
    Difference = total_ahead - total_behind,  # Calculate the variance between ahead and behind
    .groups = "drop"
  )

# Display the summary table
party_summary_stats |>
  gt() |>
  tab_header(
    title = "Summary of Presidential Candidates Running Ahead or Behind Congressional Candidates",
    subtitle = "Total Instances by Party (1976-2020)"
  ) |>
  cols_label(
    party_simplified = "Party",
    total_ahead = "Total States (Ahead)",
    total_behind = "Total States (Behind)",
    Difference = "Difference (Ahead - Behind)"
  )
```

Finally, we can observe the difference between the number of states where the presidential candidate ran ahead or behind their congressional counterparts. The table shows that both Democratic and Republican presidential candidates have run ahead more than behind, however, Republicans have a higher difference between the two categories. This indicates that Republican presidential candidates tend to outperform their congressional counterparts more frequently than Democratic candidates.

###Importing and Plotting Shapefile Data

The shapefiles we downloaded are provided in zip archives containing several files, but we only need the .shp file from each archive. In this section, we’ll walk through extracting the .shp file, loading it into R, and creating a plot from the data. The main tool we’ll use is the sf package, specifically the read_sf() function, which allows us to read shapefiles directly into R. Below, I’ll demonstrate how this process works.

```{r}
#| echo: true
#| message: false
#| warning: false
library(ggplot2)
library(sf)

if(!file.exists("nyc_borough_boundaries.zip")){
    download.file("https://data.cityofnewyork.us/api/geospatial/tqmj-j8zm?method=export&format=Shapefile", 
              destfile="nyc_borough_boundaries.zip")
}

##-
td <- tempdir(); 
zip_contents <- unzip("nyc_borough_boundaries.zip", 
                      exdir = td)
    
fname_shp <- zip_contents[grepl("shp$", zip_contents)]
nyc_sf <- read_sf(fname_shp)

```

With the following code, we can plot the shapefile data to visualize the boundaries of New York City boroughs.

```{r}
#| echo: true
#| message: false
#| warning: false
read_shp_from_zip <- function(zip_file) {
  files_in_zip <- unzip(zip_file, list = TRUE)
  
  shp_file <- files_in_zip$Name[grepl("\\.shp$", files_in_zip$Name)]
  
  if (length(shp_file) == 1) {
    unzip(zip_file, files = shp_file, exdir = tempdir())
    
    shp_path <- file.path(tempdir(), shp_file)
    
    shape_data <- read_sf(shp_path)
    
    return(shape_data)
  } else {
    message("No .shp file found in the provided zip archive.")
    return(NULL)
  }
}

```

Now we would plot the shapefile data to visualize the boundaries of New York City boroughs.

```{r}
#| echo: true
#| message: false
#| warning: false
ggplot(nyc_sf, 
       aes(geometry=geometry)) + 
    geom_sf()

```

Also we can plot the shapefile data with a fill color to visualize the boundaries of New York City boroughs.

```{r}
#| echo: true
#| message: false
#| warning: false
ggplot(nyc_sf, 
       aes(geometry=geometry, 
           fill = shape_area)) + 
    geom_sf()
```

###Electoral College Results in 2000

In this section, we will create a choropleth map to visualize the results of the 2000 U.S. Presidential Election. The map will display the winning party in each state, highlighting the electoral college winner between George W. Bush and Al Gore.

```{r}
#| echo: true
#| message: false
#| warning: false

# Step 1: Prepare Election Data
cat("Step 1: Preparing Election Data\n")
election_2000 <- DATA_PRESIDENT |>
  filter(year == 2000, office == "US PRESIDENT") |>
  group_by(state) |>
  slice_max(order_by = candidatevotes, n = 1) |>
  ungroup()

cat("Columns in election_2000 after filtering for 2000 election:\n")
print(colnames(election_2000))

# Step 2: Assign Winning Party
cat("Step 2: Assigning Winning Party\n")
election_2000 <- election_2000 |>
  mutate(
    party_winner = ifelse(party_simplified == "REPUBLICAN", "Republican", "Democrat"),
    state = tolower(state)
  )
print(head(election_2000))

# Step 3: Define Electoral College Votes (EC)
cat("Step 3: Defining Electoral College Votes\n")
ec_votes <- data.frame(
  state_po = c("AL", "AK", "AZ", "AR", "CA", "CO", "CT", "DE", "DC", "FL", "GA", "HI", "ID", "IL", "IN", "IA",
               "KS", "KY", "LA", "ME", "MD", "MA", "MI", "MN", "MS", "MO", "MT", "NE", "NV", "NH", "NJ", "NM",
               "NY", "NC", "ND", "OH", "OK", "OR", "PA", "RI", "SC", "SD", "TN", "TX", "UT", "VT", "VA", "WA",
               "WV", "WI", "WY"),
  EC = c(9, 3, 8, 6, 54, 8, 8, 3, 3, 25, 13, 4, 4, 22, 12, 7, 6, 8, 9, 4, 10, 12, 18, 10, 7, 11, 3, 5, 4, 4, 15, 5,
         33, 14, 3, 21, 8, 7, 23, 4, 8, 3, 11, 32, 5, 3, 13, 11, 5, 11, 3)
)

# Step 4: Merge EC into election data
cat("Step 4: Merging Electoral College Votes into Election Data\n")
election_2000 <- election_2000 |>
  left_join(ec_votes, by = "state_po")

cat("Checking for missing values in EC column:\n")
print(sum(is.na(election_2000$EC)))

# Step 5: Prepare Map Data
cat("Step 5: Preparing Map Data\n")
us_map <- map_data("state") |>
  mutate(region = tolower(region))

# Step 6: Merge election data with map data
cat("Step 6: Merging Election Data with Map Data\n")
map_data_with_results <- us_map |>
  left_join(election_2000, by = c("region" = "state"))
print(setdiff(us_map$region, election_2000$state))

# Step 7: Calculate State Centers for Labels
cat("Step 7: Calculating State Centers for Labels\n")
state_centers <- map_data_with_results |>
  group_by(region) |>
  summarize(
    long_center = mean(range(long, na.rm = TRUE)),
    lat_center = mean(range(lat, na.rm = TRUE)),
    state_po = first(state_po),
    EC = first(EC)
  ) |>
  ungroup()
print(head(state_centers))

# Step 8: Define Offset Labels for Northeastern States
northeast_labels <- data.frame(
  state_po = c("NH", "VT", "MA", "RI", "CT", "NJ", "DE", "MD", "DC"),
  long_offset = c(5, 4, 7, 6, 5, 6, 5, 6, 4),
  lat_offset = c(2, 1, -1, 0, -2, -1, -1, -1, -2)
)

# Join offset labels with state centers to add adjusted coordinates
state_centers <- state_centers |>
  left_join(northeast_labels, by = "state_po") |>
  mutate(
    long_center_adjusted = ifelse(!is.na(long_offset), long_center + long_offset, long_center),
    lat_center_adjusted = ifelse(!is.na(lat_offset), lat_center + lat_offset, lat_center)
  )

# Prepare connector line data for northeastern states
northeast_connectors <- state_centers |>
  filter(!is.na(long_offset) & !is.na(lat_offset))

# Step 9: Plot the Map with Insets and Connectors
cat("Step 9: Plotting the Map\n")
ggplot(map_data_with_results) +
  # Mainland US
  geom_polygon(aes(x = long, y = lat, group = group, fill = party_winner), color = "white") +
  # Alaska inset
  geom_polygon(data = subset(map_data_with_results, region == "alaska"),
               aes(x = long - 35, y = lat + 10, group = group, fill = party_winner), color = "white") +
  # Hawaii inset
  geom_polygon(data = subset(map_data_with_results, region == "hawaii"),
               aes(x = long + 50, y = lat - 5, group = group, fill = party_winner), color = "white") +
  # Party color scale
  scale_fill_manual(
    values = c("Democrat" = "blue", "Republican" = "red"),
    name = "2000 Election Winner",
    labels = c("Democrat" = "Gore", "Republican" = "Bush"),
    na.value = "grey"
  ) +
  # Labels for each state with offset adjustments for northeastern states
  geom_text(
    data = state_centers,
    aes(x = long_center_adjusted, y = lat_center_adjusted, label = paste(state_po, EC)),
    color = "black",
    size = 3,
    fontface = "bold"
  ) +
  # Connector lines for northeastern states
  geom_segment(data = northeast_connectors, 
               aes(x = long_center, y = lat_center, xend = long_center_adjusted, yend = lat_center_adjusted), 
               color = "black", linetype = "solid") +
  # Map labels and theme
  labs(
    title = "2000 Presidential Election Results by State",
    subtitle = "Bush vs. Gore",
    caption = "Data Source: MIT Election Data Science Lab"
  ) +
  theme_minimal() +
  theme(
    legend.position = "bottom",
    plot.title = element_text(hjust = 0.5, size = 16),
    plot.subtitle = element_text(hjust = 0.5, size = 12)
  )

cat("Map plot complete with Alaska, Hawaii insets and connectors for northeastern states.\n")

```

Now we can see a clear picture of how the 2000 U.S. Presidential Election played out across the country. The map shows the winning party in each state, highlighting the electoral college winner between George W. Bush and Al Gore. This visualization provides a snapshot of the election results and the distribution of electoral votes across the United States.

*Advance Chloropleth Visualization of the 2000 U.S. Presidential Election*

After this we want to visualize the results of all the U.S. Presidential Elections from 1976 to 2020. The following code will create a faceted map showing the winning party in each state for each election year, along with the corresponding electoral college votes.

```{r}

# Step 1: Prepare Election Data (for multiple years)
election_data <- DATA_PRESIDENT |>
  filter(office == "US PRESIDENT") |>
  group_by(year, state) |>
  slice_max(order_by = candidatevotes, n = 1) |>
  ungroup() |>
  mutate(
    party_winner = ifelse(party_simplified == "REPUBLICAN", "Republican", "Democrat"),
    state = tolower(state)  # Ensure compatibility with map data
  )

# Step 2: Prepare Map Data
us_map <- map_data("state") |>
  mutate(region = tolower(region))

# Step 3: Merge Election Data with Map Data
map_data_with_results <- us_map |>
  left_join(election_data, by = c("region" = "state"))

# Step 4: Plot the Animated Map with Explicit Colors
animated_map <- ggplot(map_data_with_results) +
  geom_polygon(aes(x = long, y = lat, group = group, fill = party_winner), color = "white") +
  scale_fill_manual(
    values = c("Democrat" = "#0000FF", "Republican" = "#FF0000"),  # Explicit blue and red
    name = "Election Winner",
    na.value = "grey"  # Handle unexpected NA values as grey
  ) +
  labs(
    title = "Presidential Election Results by State Over Time",
    subtitle = 'Year: {frame_time}',
    caption = "Data Source: MIT Election Data Science Lab"
  ) +
  theme_minimal() +
  theme(
    legend.position = "bottom",
    plot.title = element_text(hjust = 0.5, size = 16),
    plot.subtitle = element_text(hjust = 0.5, size = 12)
  ) +
  transition_time(year) +   # Add animation over time
  ease_aes('linear')        # Smooth animation

# Render the animation as before
#animate(
 # animated_map,
  #nframes = 100,               # Increased number of frames for smoother animation
  #fps = 10,                    # Higher frames per second for a fluid animation
  #width = 1600,                # Increased width for higher resolution
  #height = 800,                # Increased height for higher resolution
  #renderer = gifski_renderer("election_animation_high_res.gif")
#)

knitr::include_graphics("election_animation_high_res.gif")

```
![](election_animation.gif)


###Comparing the Effects of ECV Allocation Rules

Now, we are finishing the exploration of the data, we can compare the effects of different Electoral College Vote (ECV).Go through the historical voting data and assign each state’s ECVs according to various strategies:

State-Wide Winner-Take-All
District-Wide Winner-Take-All + State-Wide “At Large” Votes
State-Wide Proportional
National Proportional

```{r}

state_winner_take_all <- function(data, ec_votes) {
  # Step 1: Determine the winner in each state by popular vote
  state_winners <- data |> 
    group_by(state_po) |> 
    slice_max(order_by = candidatevotes, n = 1) |> 
    ungroup()
  
  # Debug: Check state winners to ensure they contain expected candidates and states
  print("State Winners by Popular Vote:")
  print(state_winners)

  # Step 2: Merge the state winners with the Electoral College Votes data
  state_winners <- state_winners |> 
    left_join(ec_votes, by = "state_po")
  
  # Debug: Verify ECV values after merging
  print("State Winners with ECV:")
  print(state_winners)

  # Step 3: Sum ECV by candidate
  ecv_results <- state_winners |> 
    group_by(candidate) |> 
    summarise(ECV = sum(EC, na.rm = TRUE)) |> 
    ungroup()
  
  # Debug: Check final ECV results per candidate
  print("Final ECV Allocation per Candidate:")
  print(ecv_results)
  
  return(ecv_results)
}

# Test the function with a specific year (e.g., 2000)
pres_2000 <- DATA_PRESIDENT |> filter(year == 2020, office == "US PRESIDENT")
state_winner_take_all_result <- state_winner_take_all(pres_2000, ec_votes)
print(state_winner_take_all_result)


```




