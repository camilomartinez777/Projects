---
title: "Airbnb Project / Walkability Index"
author: "Juan Camilo Martinez Benavides, "
format:
  html:
    code-fold: true
    code-summary: "Show the code"
---


# Question I answered in this project. 
Does the walkability index of NYC  affects the listing pricing?

## Objective
This project investigates how walkability influences Airbnb pricing in New York City. By integrating walkability indices with Airbnb listings data, we aim to uncover patterns that can benefit both hosts and travelers.

- **Hosts**: Leverage walkability insights to optimize pricing.
- **Travelers**: Understand walkability’s impact on accommodation choices and budgets.

## Hypothesis
Higher walkability positively correlates with higher Airbnb prices due to convenience and proximity to amenities.

## Methodology
1. **Data Collection**: Combine Airbnb listing data and EPA Walkability Index.
2. **Data Processing**: Merge datasets for analysiS and add spatial features.
3. **Data Cleaning**: Remove outliers, handle missing values, and preprocess data for analysis.
4. **Exploratory Data Analysis**: Use visualization methods to explore correlations and trends in a spatial context.(New York City)
5. **Modeling**: Conduct linear regression to quantify walkability’s impact on pricing.

---

# Data Sources and Libraries

## Data Sources
- **Airbnb Listings**: Data from 2019 and 2023.
- **Walkability Index**: EPA Walkability Index API.
- **Geospatial Data**: NYC Census Block Groups (CBGs).

## Libraries

```{r}
#| echo: true
#| message: false
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"
library(dplyr)       # Data manipulation
library(sf)          # Handling spatial data
library(geosphere)   # Geospatial calculations
library(httr)        # HTTP requests
library(tigris)      # Census and geographic data
library(ggplot2)     # Visualization
library(leaflet)     # Interactive mapping
library(gt)          # Table formatting
```

# Step 1: Data Collection

We will be using the following data sources for this project:

1. **Airbnb Listings (2019)**  
   [New York City Airbnb Open Data (2019)](https://www.kaggle.com/datasets/dgomonov/new-york-city-airbnb-open-data)

2. **Airbnb Listings (2023)**  
   [New York City Airbnb 2023 Public Data](https://www.kaggle.com/datasets/godofoutcasts/new-york-city-airbnb-2023-public-data/data)

3. **Walkability Index**  
   [Walkability Index Dataset (EPA)](https://catalog.data.gov/dataset/walkability-index7)



We load the 2019 and 2023 Airbnb listings.

```{r}
#| echo: true
#| message: false
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"
df_2019 <- read.csv("/Users/camilomartinez/STA9750-2024-FALL/Data for this project/AB_NYC_2019.csv", header = TRUE, sep = ",", stringsAsFactors = FALSE)
df_2023<- read.csv("/Users/camilomartinez/STA9750-2024-FALL/Data for this project/NYC-Airbnb-2023.csv", header = TRUE, sep = ",", stringsAsFactors = FALSE)
```

## Fetching Walkability Index Data

Now we proceed to download the [Walkability Index](https://catalog.data.gov/dataset/walkability-index7) data from the EPA API.

The documentation for the API can be found [here](https://geodata.epa.gov/arcgis/rest/services/OA/WalkabilityIndex/MapServer/0).
The following code would help you download the data from the API.

```{r}
#| echo: false
#| message: false
#| warning: false
#| results: "hide"

# Base API URL
base_url <- "https://geodata.epa.gov/arcgis/rest/services/OA/WalkabilityIndex/MapServer/0/query"

# Function to query data (limiting to 1000 records per request)
fetch_walkability_data <- function(fields, limit = 1000, state_code = NULL) {
  offset <- 0
  results <- list()
  has_more <- TRUE
  
  while (has_more) {
    # Construct query parameters
    query <- list(
      where = if (!is.null(state_code)) paste0("STATEFP = '", state_code, "'") else "1=1",
      outFields = paste(fields, collapse = ","),
      f = "geojson",
      resultOffset = offset,
      resultRecordCount = limit
    )
    
    # Send GET request
    response <- GET(base_url, query = query)
    
    # Parse response
    if (status_code(response) != 200) stop("API query failed")
    geojson_data <- content(response, "text", encoding = "UTF-8")
    features <- st_read(geojson_data, quiet = TRUE)
    
    # Add to results
    results <- append(results, list(features))
    
    # Pagination handling
    if (nrow(features) < limit) {
      has_more <- FALSE
    } else {
      offset <- offset + limit
    }
  }
  
  # Combine all data
  combined_data <- do.call(rbind, results)
  return(combined_data)
}

# Specify the fields to extract (we just need the Walkability Index and GEOID which is the block census)
fields <- c("NatWalkInd", "GEOID20")

# Fetch data for New York (State FIPS Code 36, which correspond to New York)
walkability <- fetch_walkability_data(fields, state_code = "36")

# Suppress output from st_write
invisible(capture.output(
  st_write(walkability, "NY_Walkability_Index.geojson", delete_dsn = TRUE)
))
```


# Step 2: Data Processing


Now that we have the necessary datasets, we can begin combining them for a comprehensive analysis. The process starts with cleaning and preprocessing the data to ensure consistency and accuracy. Once prepared, we will merge the datasets using their geographical information as a common key.

We begin by integrating the Airbnb datasets.

```{r}
# Combine Airbnb datasets
airbnb_combined <- bind_rows(df_2019, df_2023)

# Select only the necessary columns
airbnb_cleaned <- airbnb_combined |>
  select(neighbourhood_group, neighbourhood, latitude, longitude, room_type, price)

# Filter rows to include only 'Entire home/apt' and 'Private room'
airbnb_filtered <- airbnb_cleaned |>
  filter(room_type %in% c("Private room"))
```
Our data set has the following columns:
* Rows: 89,893
* Columns: 6

## Adding Spatial Features to Airbnb Data

To incorporate geographic context into the Airbnb dataset, we:

1. **Download Census Block Groups (CBGs):** Use the `tigris` package to get New York State CBGs.
2. **Perform a Spatial Join:** Map Airbnb latitude/longitude points to their corresponding CBGs.
3. **Add `GEOID`:** Assign each Airbnb entry a `GEOID`, aligning with the Walkability Index's `GEOID20` for seamless merging.

This enhances the Airbnb dataset with geographic information for further analysis. 

```{r}
#| echo: true
#| message: false
#| warning: false
#| code-fold: true
#| results: "hide"

# Download Census Block Groups for New York State
ny_block_groups <- block_groups(state = "NY", year = 2020, cb = TRUE)

# Check if CRS is undefined
if (is.na(st_crs(ny_block_groups))) {
  stop("CRS for ny_block_groups is undefined. Define it before proceeding.")
}

# Assign WGS84 CRS to airbnb_filtered if it uses lat/lon
if (is.na(st_crs(airbnb_filtered))) {
  airbnb_sf <- st_as_sf(airbnb_filtered, coords = c("longitude", "latitude"), crs = 4326)
} else {
  airbnb_sf <- st_as_sf(airbnb_filtered, coords = c("longitude", "latitude"))
}

# Transform CRS of airbnb_sf to match ny_block_groups if necessary
if (!st_crs(airbnb_sf)$epsg == st_crs(ny_block_groups)$epsg) {
  airbnb_sf <- st_transform(airbnb_sf, crs = st_crs(ny_block_groups))
}

# Perform spatial join to associate attributes
airbnb_with_block <- st_join(airbnb_sf, ny_block_groups, join = st_within)

# Replace point geometries with the corresponding block group geometries
airbnb_with_block$geometry <- ny_block_groups$geometry[match(
  airbnb_with_block$GEOID, ny_block_groups$GEOID
)]

#Now we proceed to merge the walkability index data with the airbnb data set.

# Step 1: Remove `sf` class from walkability
walkability_no_sf <- st_drop_geometry(walkability)

# Step 2: Perform attribute join
airbnb_with_walkability <- airbnb_with_block |>
  left_join(walkability_no_sf, by = c("GEOID" = "GEOID20"))

```


# Step 3: Data Cleaning and Outlier Removal

After combining the datasets, we focus on cleaning the data, addressing missing values, and eliminating outliers to improve data quality and enable meaningful visualizations.

## Steps:

1. **Data Cleaning:**  
   - Select relevant columns: `neighbourhood_group`, `neighbourhood`, `room_type`, `price`, `GEOID`, and `NatWalkInd`.  
   - Remove rows with missing values in the `price` or `NatWalkInd` columns.

2. **Outlier Detection and Removal:**  
   - Use the Interquartile Range (IQR) method to identify outliers in the `price` column.  
   - Remove rows with outlier prices to improve data consistency.

```{r}
#| echo: true
#| message: false
#| warning: false
#| code-fold: true
# Select and clean necessary columns
airbnb_cleaned <- airbnb_with_walkability |>
  select(neighbourhood_group, neighbourhood, room_type, price, GEOID, NatWalkInd) |> # Select relevant columns
  filter(!is.na(price) & !is.na(NatWalkInd))  # Remove rows with missing price or walkability index


#Outliers
# Define the IQR-based outlier threshold function
outlier_threshold <- function(x) {
  Q1 <- quantile(x, 0.25, na.rm = TRUE)
  Q3 <- quantile(x, 0.75, na.rm = TRUE)
  IQR <- Q3 - Q1
  lower <- Q1 - 1.5 * IQR
  upper <- Q3 + 1.5 * IQR
  return(list(lower = lower, upper = upper))
}

# Apply the function to identify outlier thresholds
thresholds <- outlier_threshold(airbnb_cleaned$price)

# Add a column identifying outliers
airbnb_cleaned <- airbnb_cleaned |>
  mutate(
    is_outlier = price < thresholds$lower | price > thresholds$upper
  )

# Count the number of outliers
num_outliers <- sum(airbnb_cleaned$is_outlier, na.rm = TRUE)

# Remove outliers
airbnb_cleaned_no_outliers <- airbnb_cleaned |>
  filter(!is_outlier)

# Enhanced histogram with removed outliers annotation
ggplot(airbnb_cleaned, aes(x = price, fill = is_outlier)) +
  geom_histogram(binwidth = 10, color = "black", alpha = 0.7, position = "identity") +
  scale_fill_manual(values = c("FALSE" = "gray", "TRUE" = "red")) +
  labs(
    title = "Airbnb Price Distribution with Outliers Highlighted",
    x = "Price",
    y = "Count",
    fill = "Outlier"
  ) +
  theme_minimal() +
  xlim(0, quantile(airbnb_cleaned$price, 0.99, na.rm = TRUE)) +  # Optional: Limit x-axis
  annotate(
    "text",
    x = quantile(airbnb_cleaned$price, 0.75, na.rm = TRUE),  # Position annotation
    y = max(table(cut(airbnb_cleaned$price, seq(0, max(airbnb_cleaned$price, na.rm = TRUE), 10)))),
    label = paste(num_outliers, "Outliers Removed"),
    color = "red",
    size = 5,
    hjust = 0
  )
```

In this step, we enhance the Airbnb dataset with geographic context and prepare it for further analysis:

1. **Load NYC Boundary Shape**: The NYC boundary shape is loaded from an open GeoJSON file to establish spatial boundaries for the analysis.(to have a better visualization)
2. **Coordinate Reference System (CRS) Transformation**: The Census Block Groups (CBGs) data is transformed to WGS84 (EPSG:4326) to ensure it aligns with the Airbnb dataset.
3. **Summarize Data for Private Rooms**: The Airbnb data is filtered to include only private room listings. These listings are grouped by `GEOID`, neighborhood, and neighborhood group to calculate:
   - **Average Price**: The mean price for private rooms in each group.
   - **Average Walkability Index**: The mean walkability index for each group. (Which is the same)
4. **Merge Datasets**: The summarized Airbnb data is joined with the CBG dataset using `GEOID` as a key, enriching the spatial dataset with pricing and walkability metrics.

```{r}
#| echo: true
#| message: false
#| warning: false
#| code-fold: true
#| results: "hide"
#| 
# Load NYC boundary shape (GeoJSON from NYC OpenData)
nyc_boundary <- st_read("https://data.cityofnewyork.us/resource/7t3b-ywvw.geojson")

ny_block_groups <- st_transform(ny_block_groups, crs = 4326)

# Step 1: Group and summarize data for private rooms
private_room_avg_price <- airbnb_cleaned_no_outliers |>
  filter(room_type == "Private room") |>  # Filter for private rooms
  st_set_geometry(NULL) |>                # Temporarily remove geometry
  group_by(GEOID, neighbourhood_group, neighbourhood) |>  # Group by GEOID and neighborhoods
  summarize(
    avg_price = mean(price, na.rm = TRUE),       # Calculate average price
    avg_NatWalkInd = mean(NatWalkInd, na.rm = TRUE)  # Calculate average walkability index
  )

# Join the average price back to the original spatial dataset
ny_block_groups_with_price <- ny_block_groups |>
  left_join(private_room_avg_price, by = c("GEOID" = "GEOID"))
```

# Step 4: Exploratory Data Analysis

## Visualizing the Average Price Distribution
```{r}
#| echo: true
#| message: false
#| warning: false
#| code-fold: true
#| 
# Create a color palette for the heatmap
pal <- colorNumeric(
  palette = "YlOrRd",  # Choose a heatmap color palette
  domain = ny_block_groups_with_price$avg_price,  # Domain of average prices
  na.color = "transparent"  # Handle missing values
)

# Create the Leaflet map with a heatmap-like color gradient
leaflet(data = ny_block_groups_with_price) |>
  addTiles() |>  # Add default OpenStreetMap tiles
  addPolygons(
    fillColor = ~pal(avg_price),  # Use color palette for the fill color
    color = "black",              # Border color
    weight = 1,                   # Border weight
    fillOpacity = 0.7,            # Transparency for the fill
    popup = ~paste0(
      "GEOID: ", GEOID, "<br>",
      "Average Price: $", round(avg_price, 2)
    )
  ) |>
  addLegend(
    pal = pal, values = ny_block_groups_with_price$avg_price,
    position = "bottomright",
    title = "Average Price",
    opacity = 1
  ) |>
  setView(lng = -73.935242, lat = 40.730610, zoom = 12)  # Center on NYC

```

## Walkabilty index Visualization

Now we would create a heatmap to visualize the Walkability Index across different neighborhoods in New York City.

```{r}
#| echo: true
#| message: false
#| warning: false
#| code-fold: true

# Create a color palette for the heatmap
pal <- colorNumeric(
  palette = "Greens",  # Green color palette
  domain = ny_block_groups_with_price$avg_NatWalkInd,  # Domain of average prices
  na.color = "transparent"  # Handle missing values
)
# Create the Leaflet map with a heatmap-like color gradient
leaflet(data = ny_block_groups_with_price) |>
  addTiles() |>  # Add default OpenStreetMap tiles
  addPolygons(
    fillColor = ~pal(avg_NatWalkInd),  # Use color palette for the fill color
    color = "black",              # Border color
    weight = 1,                   # Border weight
    fillOpacity = 0.7,            # Transparency for the fill
    popup = ~paste0(
      "GEOID: ", GEOID, "<br>",
      "Walkability Index", round(avg_NatWalkInd, 2)
    )
  ) |>
  addLegend(
    pal = pal, values = ny_block_groups_with_price$avg_NatWalkInd,
    position = "bottomright",
    title = "Walkability Index",
    opacity = 1
  ) |>
  setView(lng = -73.935242, lat = 40.730610, zoom = 12)  # Center on NYC


```

# Step 5: Modeling: Linear Regression Analysis

We build and analyze a linear regression model to evaluate the impact of walkability on Airbnb prices:

1. **Fit the Model**: The regression predicts `avg_price` based on `avg_NatWalkInd` (walkability index).
2. **Extract Results**: Key outputs like coefficients, p-values, and R-squared are calculated to summarize the model's performance.
3. **Format Table**: Results are structured into a clear, interpretable table using the `gt` package.

```{r}
#| echo: true
#| message: false
#| warning: false
#| code-fold: true
# Fit a linear regression model with only walkability
model_walkability <- lm(avg_price ~ avg_NatWalkInd, data = private_room_avg_price)

# Extract model summary
summary_output <- summary(model_walkability)

# Extract coefficients and relevant values
coefficients <- summary_output$coefficients
coefficients_df <- data.frame(
  Predictor = rownames(coefficients),
  Coefficient = coefficients[, "Estimate"],
  PValue = coefficients[, "Pr(>|t|)"]
)

# Add R-squared and adjusted R-squared as additional rows
coefficients_df <- rbind(
  coefficients_df,
  data.frame(Predictor = "R-Squared", Coefficient = summary_output$r.squared, PValue = NA)
  )
# Update the label for walkability in the Predictor column
coefficients_df$Predictor <- gsub("avg_NatWalkInd", "Walkability Index", coefficients_df$Predictor)

# Create a summary table using gt
summary_table <- gt(coefficients_df) |>
  gt::tab_header(
    title = "Walkability Model Summary"
  ) |>
  gt::cols_label(
    Predictor = "Predictor",
    Coefficient = "Coefficient",
    PValue = "P-Value"
  ) |>
  gt::fmt_number(
    columns = c(Coefficient, PValue),
    decimals = 3
  ) |>
  gt::cols_align(
    align = "center",
    columns = everything()
  )

# Print the table
summary_table
```

This table summarizes a linear regression analysis of the relationship between the Walkability Index and Airbnb private room prices:

# Step 6: Results and Insights

1. **Intercept (67.775)**:
   - This is the estimated average price when the Walkability Index is zero.
   - While statistically significant (P = 0.000), it's not very useful since a Walkability Index of zero is unrealistic.

2. **Walkability Index (0.330)**:
   - For every one-point increase in the Walkability Index, prices rise by $0.33.
   - It’s statistically significant (P = 0.016), but the impact is very small.

3. **R-Squared (0.001)**:
   - Only 0.1% of the variation in prices is explained by the Walkability Index.
   - This suggests walkability is not a strong factor in predicting Airbnb prices, and other factors are more important.

## Insights

- Walkability has a small, but statistically significant, effect on Airbnb prices.
- Factors like amenities, neighborhood features, and room size likely have a bigger impact.
- More detailed analysis with additional factors could give a clearer picture of what drives Airbnb pricing.

### Recommendations

1. **Add More Factors**:
   - Include details like nearby parks, grocery stores, schools, and crime rates.
   - Look at things like nightlife, noise levels, and access to public transport.

2. **Use More Geographic Data**:
   - Combine the Walkability Index with data on transit stops, street layout, and nearby shops.
   - Create maps to see how prices vary by location and walkability.

3. **Compare Different Segments**:
   - Study how walkability affects different property types, like shared rooms versus entire homes.
   - Look at differences between cities, suburbs, and rural areas.

4. **Refine Walkability Measures**:
   - Focus on specific parts of the Walkability Index, like pedestrian-friendly streets or access to daily necessities.
   - Add data like real-time foot traffic or reviews about walkability.

5. **Try Advanced Methods**:
   - Use other machine learning to find out which factors matter most for prices.
   - Group neighborhoods by similar walkability and pricing patterns for better insights.